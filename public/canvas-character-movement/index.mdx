---
title: Reactì—ì„œ Canvasë¥¼ ì´ìš©í•œ ìºë¦­í„° ì´ë™ êµ¬í˜„í•˜ê¸°
introduce: Reactì—ì„œ Canvasë¥¼ ì‚¬ìš©í•˜ì—¬ ìºë¦­í„° ì´ë™ì„ êµ¬í˜„í•œ ê²½í—˜ì„ ê³µìœ í•©ë‹ˆë‹¤.
createdAt: '2022.11.05'
tags: ['frontend', 'react']
category: ê°œë°œ
image: /canvas-character-movement/7.gif
---

ì´ë²ˆ ê¸€ì—ì„œëŠ” Canvasë¥¼ ì‚¬ìš©í•˜ì—¬ ìºë¦­í„° ì´ë™ì„ êµ¬í˜„í•œ ê²½í—˜ì„ ê³µìœ í•´ë³´ë ¤ í•©ë‹ˆë‹¤.
ê·¸ì € ì´ë™ ë¿ ì•„ë‹ˆë¼, **ìºë¦­í„°ê°€ ë§ˆì¹˜ ê±·ëŠ” ë“¯í•œ ì• ë‹ˆë©”ì´ì…˜**ì„ í‘œí˜„í–ˆìŠµë‹ˆë‹¤. (ì œì¼ ì–´ë ¤ì› ì–´ìš”..)

ì°¸ê³ ë¡œ, ê¸€ ì†ì— ì½”ë“œê°€ ë§ìŠµë‹ˆë‹¤.. ì½”ë“œ ì£¼ì˜â—ï¸

<br />

## Canvas?

Canvas APIëŠ” JavaScript ë° HTML `<canvas>` ìš”ì†Œë¥¼ í†µí•´ ê·¸ë˜í”½ì„ ê·¸ë¦¬ëŠ” ìˆ˜ë‹¨ì„ ì œê³µí•©ë‹ˆë‹¤.
ì• ë‹ˆë©”ì´ì…˜, ê²Œì„ ê·¸ë˜í”½, ë°ì´í„° ì‹œê°í™”, ì‚¬ì§„ ì¡°ì‘ ë° ì‹¤ì‹œê°„ ë¹„ë””ì˜¤ ì²˜ë¦¬ì— ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ìºë¦­í„° ì´ë™ì„ ìœ„í•´ **ë™ì  ê·¸ë˜í”½ ì¡°ì‘ì´ í•„ìš”**í•˜ê¸° ë•Œë¬¸ì— Canvas APIë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤!

<br />

## `useCanvas` Hook êµ¬í˜„

ë¨¼ì € **canvasë¥¼ ì¡°ì‘í•  ìˆ˜ ìˆëŠ” í™˜ê²½ì„ ë§ˆë ¨**í•©ë‹ˆë‹¤.

```ts
// useCanvas.ts

import { useRef, useEffect } from "react";

const useCanvas = (setCanvas: (canvas: HTMLCanvasElement) => void) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    canvas && setCanvas(canvas);
  }, []);

  return canvasRef;
};

export default useCanvas;
```

`useRef` Hookì„ ì´ìš©í•œ `canvasRef`ë¥¼ ë¦¬í„´í•˜ë„ë¡ í–ˆìŠµë‹ˆë‹¤.
canvas ìš”ì†Œë¥¼ í›„ì— ë” ìƒì„±í•´ì•¼ í•  ìˆ˜ë„ ìˆê² ë‹¤ëŠ” ìƒê°ì— Custom Hookìœ¼ë¡œ ë¶„ë¦¬í–ˆìŠµë‹ˆë‹¤.

`useCanvas` Hookì„ ì•„ë˜ ì½”ë“œì—ì„œì²˜ëŸ¼ í™œìš©í•˜ì—¬ ìƒì„±í•œ canvasë¥¼ ì¡°ì‘í•  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤.

```tsx
// Canvas.tsx

import React from 'react';
import { Wrapper } from './style';
import useCanvas from '@src/hooks/useCanvas';
import mapBackground from '@public/images/map_background.jpeg';

const WIDTH = 1000;
const HEIGHT = 700;

const Canvas = () => {
  const canvasRef = useCanvas((canvas) => {
    canvas.width = WIDTH;
    canvas.height = HEIGHT;
    canvas.style.background = `url(${mapBackground})`;
  });

  return (
    <Wrapper>
      <canvas ref={canvasRef} />
    </Wrapper>
  );
};

export default Canvas;
```

<br />

canvasê°€ ì˜ ìƒì„±ë˜ì—ˆë„¤ìš” ğŸ‘

<img src="/canvas-character-movement/1.png" />

<br />
<br />

## ìºë¦­í„° ê·¸ë¦¬ê¸°

ìºë¦­í„°ì˜ ì´ë™ì„ ìœ„í•´ í•„ìš”í•œ ì •ë³´ê°€ ë¬´ì—‡ì´ ìˆì„ê¹Œìš”?

- ìºë¦­í„°ì˜ ìœ„ì¹˜ (x, y)
- ìºë¦­í„°ì˜ ì´ë™ ë°©í–¥

í˜„ì¬ë¡œì„œëŠ” ì´ ë‘ê°€ì§€ ì •ë„ê°€ í•„ìš”í•˜ê² ë„¤ìš”.
ê·¸ëŸ¼ ìœ„ì¹˜ì™€ ë°©í–¥ Stateë¥¼ ìƒì„±í•˜ë©´ ë ê¹Œìš”? 
No! **Stateì˜ ë³€ê²½ì´ ì¼ì–´ë‚˜ë©´ ì»´í¬ë„ŒíŠ¸ì˜ ë¦¬ë Œë”ë§ì´ ë°œìƒí•©ë‹ˆë‹¤.**
ë”°ë¼ì„œ ìºë¦­í„°ê°€ ì´ë™í•  ë•Œë§ˆë‹¤ ë¦¬ë Œë”ë§ì´ ìˆ˜í–‰ë˜ê² ì£ .

ê·¸ëŸ¼ ìœ„ì¹˜, ë°©í–¥ ì •ë³´ë¥¼ ì–´ë–»ê²Œ ê´€ë¦¬í• ê¹Œìš”? **í´ë˜ìŠ¤ë¥¼ í•˜ë‚˜ ë§Œë“­ì‹œë‹¤!**

```ts
// Character.ts

interface Position {
  x: number;
  y: number;
}

enum Direction {
  DOWN = 0,
  UP = 1,
  LEFT = 2,
  RIGHT = 3,
}

class Character {
  private canvas: HTMLCanvasElement;
  private ctx: CanvasRenderingContext2D | null = null;
  private position: Position = { x: 0, y: 0 };
  private direction: number = Direction.DOWN;

  constructor(canvas: HTMLCanvasElement) {
    this.canvas = canvas;
    this.ctx = this.canvas.getContext('2d');
  }
}

export default Character;
```

<br />

ìœ„ `Character` í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±ì„ ì•„ë˜ì™€ ê°™ì´ `useRef`ì„ ì‚¬ìš©í•˜ì—¬ ë¶ˆí•„ìš”í•œ ë¦¬ë Œë”ë§ì„ ì¤„ì…ë‹ˆë‹¤.

```tsx
// Canvas.tsx

...

const Canvas = () => {
  const charcterRef = useRef<Character | null>(null);
  const canvasRef = useCanvas((canvas) => {
    canvas.width = WIDTH;
    canvas.height = HEIGHT;
    canvas.style.background = `url(${mapBackground})`;
    charcterRef.current = new Character(canvas);
  });
 
  return (
    <Wrapper>
      <canvas ref={canvasRef} />
    </Wrapper>
  );
};

...
```

<br />
<br />

### * ìºë¦­í„° ì´ë¯¸ì§€ ê°€ì ¸ì˜¤ê¸°

ì´ì œ ë°©í–¥ë³„ ìºë¦­í„° ì´ë¯¸ì§€ë¥¼ ê°€ì ¸ì˜¤ëŠ” ê¸°ëŠ¥ì„ êµ¬í˜„í•´ë´…ì‹œë‹¤.
ì €ëŠ” [https://itch.io/game-assets/free/tag-top-down](https://itch.io/game-assets/free/tag-top-down) ì—ì„œ ì•„ë˜ ë¬´ë£Œ ìºë¦­í„° ì´ë¯¸ì§€ë¥¼ ë‹¤ìš´ ë°›ì•˜ìŠµë‹ˆë‹¤.

<img src="/canvas-character-movement/2.png" />

<br />

ìœ„ ì´ë¯¸ì§€ë¥¼ 32pxë¡œ ëª¨ë‘ ìë¥´ê³  ë°©í–¥ì— ë”°ë¼ íŠ¹ì • ì´ë¯¸ì§€ë¥¼ canvasì— ê·¸ë¦´ ê²ƒì…ë‹ˆë‹¤.
ëª¨ë“  ì´ë¯¸ì§€ë¥¼ í™œìš©í•˜ë©´ ì¢‹ê² ì§€ë§Œ ê° ë°©í–¥ì— ë”°ë¥¸ ê±·ëŠ” ì´ë¯¸ì§€ ë‘˜, ì„œëŠ” ì´ë¯¸ì§€ í•˜ë‚˜ë§Œì„ ì‚¬ìš©í•˜ê² ìŠµë‹ˆë‹¤.

<br />

<img src="/canvas-character-movement/3.png" width="300" />

<br />

**ë§¤ë²ˆ ì´ë¯¸ì§€ë¥¼ ë¡œë“œí•˜ê²Œ ë˜ë©´ `ERR_INSUFFICIENT_RESOURCES` ì—ëŸ¬ê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.**
í•œë²ˆ ë¡œë“œí•œ ì´ë¯¸ì§€ë¥¼ ì¬ì‚¬ìš©í•˜ê¸° ìœ„í•´ ì•„ë˜ ì½”ë“œì™€ ê°™ì´ ì´ë¯¸ì§€ ê°ì²´ë¥¼ ìƒì„±í•´ë†“ìŠµë‹ˆë‹¤.

```ts
// CharacterImages.ts

import manDown from '@public/images/man_down.png';
import manDownWalk from '@public/images/man_down_walk.png';
import manUp from '@public/images/man_up.png';
import manUpWalk from '@public/images/man_up_walk.png';
import manLeft from '@public/images/man_left.png';
import manLeftWalk from '@public/images/man_left_walk.png';
import manRight from '@public/images/man_right.png';
import manRightWalk from '@public/images/man_right_walk.png';

const init: { [key: string]: HTMLImageElement } = {};
const imageSrc = {
  manDown,
  manDownWalk,
  manUp,
  manUpWalk,
  manLeft,
  manLeftWalk,
  manRight,
  manRightWalk,
};

const CharacterImages = Object.entries(imageSrc).reduce(
  (images, [key, src]) => {
    const image = new Image();
    image.src = src;
    images[key] = image;
    return images;
  },
  init
);

export default CharacterImages;
```

<br />

ìƒì„±í•œ ì´ë¯¸ì§€ ê°ì²´ë¥¼ í™œìš©í•˜ì—¬ ë°©í–¥ë³„ ìºë¦­í„° ì´ë¯¸ì§€ë¥¼ ê°€ì ¸ì˜¤ëŠ” í•¨ìˆ˜ë¥¼ `Character` í´ë˜ìŠ¤ì— êµ¬í˜„í•©ë‹ˆë‹¤.

```ts
// Character.ts

import CharacterImages from './CharacterImages';

...

enum Direction {
  DOWN = 0,
  UP = 1,
  LEFT = 2,
  RIGHT = 3,
}

class Character {

  ...
  
  private getImageByDirection(direction: number, isWalking: boolean) {
    const {
      manDown,
      manDownWalk,
      manUp,
      manUpWalk,
      manLeft,
      manLeftWalk,
      manRight,
      manRightWalk,
    } = CharacterImages;

    switch (direction) {
      case Direction.UP:
        return isWalking ? manUpWalk : manUp;
      case Direction.DOWN:
        return isWalking ? manDownWalk : manDown;
      case Direction.LEFT:
        return isWalking ? manLeftWalk : manLeft;
      case Direction.RIGHT:
        return isWalking ? manRightWalk : manRight;
      default:
        return null;
    }
  }
}
```

ìºë¦­í„°ë¥¼ ê·¸ë¦¬ê¸° ìœ„í•œ ì¤€ë¹„ë¥¼ ë§ˆì³¤ìŠµë‹ˆë‹¤! ì´ì œ ìºë¦­í„°ë¥¼ ê·¸ë ¤ë´…ì‹œë‹¤.

<br />

### * `requestAnimationFrame`

ìºë¦­í„°ë¥¼ ê·¸ë¦¬ê¸° ìœ„í•´ì„œ `window.requestAnimationFrame` í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.

> ğŸ’¡ `requestAnimationFrame`ì€ ì½œë°±ì„ ì¸ìë¡œ ë°›ê³ , í™”ë©´ ì£¼ì‚¬ìœ¨ì— ë§ì¶° ì½œë°±ì´ í˜¸ì¶œë©ë‹ˆë‹¤.

ì´ëŸ¬í•œ `requestAnimationFrame`ì„ ì¬ê·€ í˜¸ì¶œí•˜ì—¬ ì• ë‹ˆë©”ì´ì…˜ì„ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
ë§Œì•½ í˜„ì¬ ëª¨ë‹ˆí„°ì˜ ì£¼ì‚¬ìœ¨ì´ 60Hzë¼ë©´ ì½œë°± í•¨ìˆ˜ê°€ 1ì´ˆì— 60ë²ˆ ì‹¤í–‰ë˜ëŠ” ê²ƒì…ë‹ˆë‹¤.
ë”°ë¼ì„œ ì‚¬ìš©ìëŠ” ë””ìŠ¤í”Œë ˆì´ì— ìµœì í™”ëœ ì• ë‹ˆë©”ì´ì…˜ì„ ëŠë‚„ ìˆ˜ ìˆê²Œ ë©ë‹ˆë‹¤.

```ts
private runAnimationFrame() {
  this.draw();
  requestAnimationFrame(this.runAnimationFrame.bind(this));
}

private draw() {
  1. ëª¨ë“  ê·¸ë˜í”½ ìš”ì†Œ ì§€ìš°ê¸°
  2. íŠ¹ì • ì¢Œí‘œì— ìºë¦­í„° ì´ë¯¸ì§€ ê·¸ë˜í”½ ìƒì„±
}
```

`requestAnimationFrame`ì„ í™œìš©í•œ ìœ„ ì½”ë“œë¥¼ í†µí•´ ìºë¦­í„°ë¥¼ ê·¸ë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
**ë§¤ í”„ë ˆì„ë§ˆë‹¤ ìºë¦­í„°ë¥¼ ì§€ìš°ê³  ê·¸ë¦¬ëŠ” ê²ƒì„ ë°˜ë³µí•˜ë©´ì„œ ë§ˆì¹˜ ì´ë™í•˜ëŠ” ê²ƒì²˜ëŸ¼ í‘œí˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.**

ìœ„ ì½”ë“œë¥¼ ì¶”ê°€í•œ `Character` í´ë˜ìŠ¤ ì½”ë“œì…ë‹ˆë‹¤!

```ts
// Character.ts

import CharacterImages from './CharacterImages';

interface Position {
  x: number;
  y: number;
}

enum Direction {
  DOWN = 0,
  UP = 1,
  LEFT = 2,
  RIGHT = 3,
}

const SIZE = 64;

class Character {
  private canvas: HTMLCanvasElement;
  private ctx: CanvasRenderingContext2D | null = null;
  private position: Position = { x: 0, y: 0 };
  private direction: number = Direction.DOWN;

  constructor(canvas: HTMLCanvasElement) {
    this.canvas = canvas;
    this.ctx = this.canvas.getContext('2d');
    this.runAnimationFrame();
  }

  private runAnimationFrame() {
    this.draw();
    requestAnimationFrame(this.runAnimationFrame.bind(this));
  }

  private draw() {
    const { x, y } = this.position;
    const image = this.getImageByDirection(0, false);

    if (!this.ctx || !image) {
      return;
    }

    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.ctx.drawImage(image, x, y, SIZE, SIZE);
  }

  private getImageByDirection(direction: number, isWalking: boolean) {
    const {
      manDown,
      manDownWalk,
      manUp,
      manUpWalk,
      manLeft,
      manLeftWalk,
      manRight,
      manRightWalk,
    } = CharacterImages;

    switch (direction) {
      case Direction.UP:
        return isWalking ? manUpWalk : manUp;
      case Direction.DOWN:
        return isWalking ? manDownWalk : manDown;
      case Direction.LEFT:
        return isWalking ? manLeftWalk : manLeft;
      case Direction.RIGHT:
        return isWalking ? manRightWalk : manRight;
      default:
        return null;
    }
  }
}

export default Character;
```

`this.getImageByDirection(0, false)`ë¥¼ í˜¸ì¶œí•¨ìœ¼ë¡œì¨ ì•„ë˜ ë°©í–¥ìœ¼ë¡œ ì •ì§€ë˜ì–´ ìˆëŠ” ìºë¦­í„° ì´ë¯¸ì§€ë¥¼ ê·¸ë ¸ìŠµë‹ˆë‹¤.

<br />

<img src="/canvas-character-movement/4.png" />

<br />
<br />

## ìºë¦­í„° ì´ë™ êµ¬í˜„í•˜ê¸°

ë¨¼ì € í‚¤ë³´ë“œ ì´ë²¤íŠ¸ë¥¼ ë°”ì¸ë”© í•©ì‹œë‹¤.
ì•„ë˜ `handleArrowKeydown` ë©”ì„œë“œë¥¼ `Character` í´ë˜ìŠ¤ì— ì¶”ê°€í•©ë‹ˆë‹¤.

```ts
// Character.ts

...

hadleArrowKeyDown() {
  const distance = SIZE;
  const ArrowKeys = [
    {
      code: '38',
      string: 'ArrowUp',
      movement: { x: 0, y: -distance },
      isMoveable: () => this.position.y > 0,
    },
    {
      code: '40',
      string: 'ArrowDown',
      movement: { x: 0, y: distance },
      isMoveable: () => this.position.y < this.canvas.height - SIZE,
    },
    {
      code: '39',
      string: 'ArrowRight',
      movement: { x: distance, y: 0 },
      isMoveable: () => this.position.x < this.canvas.width - SIZE,
    },
    {
      code: '37',
      string: 'ArrowLeft',
      movement: { x: -distance, y: 0 },
      isMoveable: () => this.position.x > 0,
    },
  ];

  const handler = (e: KeyboardEvent) => {
    for (let i = 0; i < ArrowKeys.length; i++) {
      const { code, string, movement, isMoveable } = ArrowKeys[i];
      if ([code.toString(), string].includes(e.key) && isMoveable()) {
        this.position.x += movement.x;
        this.position.y += movement.y;
      }
    }
  };

  return (e: KeyboardEvent) => handler(e);
}

...
```

ì´ ë©”ì„œë“œëŠ” í‚¤ë³´ë“œ ì´ë²¤íŠ¸ì— ë”°ë¥¸ ìºë¦­í„° ìœ„ì¹˜ë¥¼ ë³€ê²½í•˜ë„ë¡ í•©ë‹ˆë‹¤.
ì´ë•Œ, ìºë¦­í„°ê°€ canvasë¥¼ ë²—ì–´ë‚˜ì§€ ëª»í•˜ê²Œ `isMoveable` ì´ë¼ëŠ” ì´ë™ ì¡°ê±´ë¬¸ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.

ê·¸ë¦¬ê³  `Canvas` ì»´í¬ë„ŒíŠ¸ì—ì„œ ì´ë²¤íŠ¸ ë°”ì¸ë”© ë° ë°”ì¸ë”© í•´ì œë¥¼ ìˆ˜í–‰í•˜ë„ë¡ í•©ë‹ˆë‹¤.

```tsx
// Canvas.tsx

...

const Canvas = () => {
  const charcterRef = useRef<Character | null>(null);
  const canvasRef = useCanvas((canvas) => {
    canvas.width = WIDTH;
    canvas.height = HEIGHT;
    canvas.style.background = `url(${mapBackground})`;
    charcterRef.current = new Character(canvas);

    if (charcterRef.current) {
      document.addEventListener('keydown', charcterRef.current.hadleArrowKeyDown());
    }
  });

  // ì–¸ë§ˆìš´íŠ¸ì‹œ ì´ë²¤íŠ¸ ë°”ì¸ë”© í•´ì œ
  useEffect(() => {
    return () => {
      if (charcterRef.current) {
        document.removeEventListener('keydown', charcterRef.current.hadleArrowKeyDown());
      }
    };
  }, []);

  return (
    <Wrapper>
      <canvas ref={canvasRef} />
    </Wrapper>
  );
};

export default Canvas;
```

<br />

ì˜ ë™ì‘í•˜ë„¤ìš” ğŸ˜

<img src="/canvas-character-movement/5.gif" />

<br />

ê·¸ëŸ°ë° ë°©í–¥í‚¤ë¥¼ ê¾¹ ëˆ„ë¥´ë©´ ìºë¦­í„°ê°€ ë¹ ë¥´ê²Œ ì´ë™í•©ë‹ˆë‹¤.
ì¼ì • ì†ë„ë¡œ ì´ë™í•˜ëŠ” ê²ƒì´ ì¢‹ê² ì£ ?
ì–´ë–»ê²Œ í•  ìˆ˜ ìˆì„ê¹Œìš”?

ë°”ë¡œ **throttling(ì“°ë¡œí‹€ë§)** ì„ í™œìš©í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤! (throttlingì˜ ê°œë…ì— ëŒ€í•´ì„œëŠ” í•´ë‹¹ ê¸€ì—ì„œ ë‹¤ë£¨ì§€ ì•Šê² ìŠµë‹ˆë‹¤.)
`throttle` ìœ í‹¸ í•¨ìˆ˜ë¥¼ ë§Œë“­ì‹œë‹¤.

```ts
// throttle.ts

function throttle(func: Function, delay: number = 1000) {
  let timer: NodeJS.Timeout | null = null;

  return (...args: unknown[]) => {
    if (timer) {
      return;
    }
    func(...args);
    timer = setTimeout(() => {
      timer = null;
    }, delay);
  };
}

export default throttle;
```

ìƒì„±í•œ `throttle` ìœ í‹¸ í•¨ìˆ˜ë¥¼ ì•„ë˜ì™€ ê°™ì´ ì ìš©í•©ë‹ˆë‹¤.

```ts
// Character.ts

import throttle from '@src/utils/throttle';

...

hadleArrowKeyDown() {
  ...

  const handler = throttle((e: KeyboardEvent) => {
    for (let i = 0; i < ArrowKeys.length; i++) {
      const { code, string, movement, isMoveable } = ArrowKeys[i];
      if ([code.toString(), string].includes(e.key) && isMoveable()) {
        this.position.x += movement.x;
        this.position.y += movement.y;
      }
    }
  }, 500);

  return (e: KeyboardEvent) => handler(e);
}

...
```

<br />

ì¼ì • ì†ë„ë¡œ ì´ë™í•˜ë„¤ìš” ğŸ‘

<img src="/canvas-character-movement/6.gif" />

<br />
<br />

## ìºë¦­í„° ê±·ëŠ” ì• ë‹ˆë©”ì´ì…˜ êµ¬í˜„í•˜ê¸°

ì´ì œ ë§ˆì§€ë§‰ìœ¼ë¡œ ìºë¦­í„°ê°€ ë§ˆì¹˜ ê±·ëŠ” ë“¯í•œ ì• ë‹ˆë©”ì´ì…˜ì„ êµ¬í˜„í•´ë´…ì‹œë‹¤.
ì €ëŠ” `requestAnimationFrame`ì„ í™œìš©í–ˆìŠµë‹ˆë‹¤.
í‚¤ë³´ë“œ ì´ë²¤íŠ¸ ë°œìƒì‹œ **íŠ¹ì • í”„ë ˆì„ x ë™ì•ˆì— ê±·ëŠ” ì´ë¯¸ì§€ë¥¼ ê·¸ë¦¬ê³  íŠ¹ì • í”„ë ˆì„ xê°€ ì§€ë‚˜ë©´ ì„œëŠ” ì´ë¯¸ì§€ë¥¼ ê·¸ë¦¬ëŠ” ë°©ë²•ì„ ì‚¬ìš©**í–ˆìŠµë‹ˆë‹¤.

```ts
// Character.ts

import CharacterImages from './CharacterImages';
import throttle from '@src/utils/throttle';

interface Position {
  x: number;
  y: number;
}

enum Direction {
  DOWN = 0,
  UP = 1,
  LEFT = 2,
  RIGHT = 3,
}

const SIZE = 64;

class Character {
  private canvas: HTMLCanvasElement;
  private ctx: CanvasRenderingContext2D | null = null;
  private position: Position = { x: 0, y: 0 };
  private direction: number = Direction.DOWN;
  private frameDelay = 10;
  private frameCount = 0;

  constructor(canvas: HTMLCanvasElement) {
    this.canvas = canvas;
    this.ctx = this.canvas.getContext('2d');
    this.runAnimationFrame();
  }

  private runAnimationFrame() {
    // (2)
    this.draw(++this.frameCount < this.frameDelay);
    requestAnimationFrame(this.runAnimationFrame.bind(this));
  }

  private draw(isDelayIn: boolean) {
    const { x, y } = this.position;
    // (3)
    const image = this.getImageByDirection(this.direction, isDelayIn);

    if (!this.ctx || !image) {
      return;
    }

    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.ctx.drawImage(image, x, y, SIZE, SIZE);
  }

  private getImageByDirection(direction: number, isWalking: boolean) {
    const {
      manDown,
      manDownWalk,
      manUp,
      manUpWalk,
      manLeft,
      manLeftWalk,
      manRight,
      manRightWalk,
    } = CharacterImages;

    switch (direction) {
      case Direction.UP:
        return isWalking ? manUpWalk : manUp;
      case Direction.DOWN:
        return isWalking ? manDownWalk : manDown;
      case Direction.LEFT:
        return isWalking ? manLeftWalk : manLeft;
      case Direction.RIGHT:
        return isWalking ? manRightWalk : manRight;
      default:
        return null;
    }
  }

  hadleArrowKeyDown() {
    const distance = SIZE;
    const ArrowKeys = [
      {
        code: '38',
        string: 'ArrowUp',
        direction: Direction.UP,
        movement: { x: 0, y: -distance },
        isMoveable: () => this.position.y > 0,
      },
      {
        code: '40',
        string: 'ArrowDown',
        direction: Direction.DOWN,
        movement: { x: 0, y: distance },
        isMoveable: () => this.position.y < this.canvas.height - SIZE,
      },
      {
        code: '39',
        string: 'ArrowRight',
        direction: Direction.RIGHT,
        movement: { x: distance, y: 0 },
        isMoveable: () => this.position.x < this.canvas.width - SIZE,
      },
      {
        code: '37',
        string: 'ArrowLeft',
        direction: Direction.LEFT,
        movement: { x: -distance, y: 0 },
        isMoveable: () => this.position.x > 0,
      },
    ];

    const handler = throttle((e: KeyboardEvent) => {
      for (let i = 0; i < ArrowKeys.length; i++) {
        const { code, string, direction, movement, isMoveable } = ArrowKeys[i];
        if ([code.toString(), string].includes(e.key) && isMoveable()) {
          this.position.x += movement.x;
          this.position.y += movement.y;
          this.direction = direction;
        }
        // (1)
        this.frameCount = 0;
      }
    }, 500);

    return (e: KeyboardEvent) => handler(e);
  }
}

export default Character;
```

`Character` í´ë˜ìŠ¤ ì „ì²´ ì½”ë“œì…ë‹ˆë‹¤. ì£¼ì„ìœ¼ë¡œ í‘œê¸°ëœ ë²ˆí˜¸ë¥¼ ì£¼ì‹œí•´ì£¼ì„¸ìš”!

- (1) : í‚¤ë³´ë“œ ì´ë²¤íŠ¸ ë°œìƒì‹œ frame countë¥¼ 0ìœ¼ë¡œ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
- (2) : frame countê°€ frame delay(= 10)ë³´ë‹¤ ì‘ì€ì§€ ì—¬ë¶€ë¥¼ `draw` ë©”ì„œë“œì— ì „ë‹¬í•©ë‹ˆë‹¤.
- (3) : ì¸ìë¡œ ë°›ì€ `isDelayIn`ì´ ê³§ ìºë¦­í„°ì˜ ê±¸ìŒ ì—¬ë¶€ì´ë¯€ë¡œ `isDelayIn`ì„ `getImageByDirection` ë©”ì„œë“œì— ì „ë‹¬í•©ë‹ˆë‹¤.

<br />

ì™„ì„± ğŸ™Œ

<img src="/canvas-character-movement/7.gif" />

<br />
<br />

## ì‚¬ìš©ì ë§ì¶¤ frame delay ì„¤ì •í•˜ê¸°

í˜„ì¬ êµ¬í˜„í•œ ìºë¦­í„° ì´ë™ì—ëŠ” í° ë¬¸ì œê°€ ìˆìŠµë‹ˆë‹¤.
**ì‚¬ìš©ìë§ˆë‹¤ ëª¨ë‹ˆí„° ì£¼ì‚¬ìœ¨ì´ ë‹¤ë¥´ë‹¤ëŠ”....**
ë”°ë¼ì„œ 60Hzë³´ë‹¤ ì£¼ì‚¬ìœ¨ì´ í° í™˜ê²½ì—ì„œëŠ” ê±·ëŠ” ì• ë‹ˆë©”ì´ì…˜ì´ ì•ˆë³´ì´ê²Œ ë  ê²ƒì…ë‹ˆë‹¤.
ê·¸ë˜ì„œ **ì‚¬ìš©ìì˜ ì£¼ì‚¬ìœ¨ì„ íŒŒì•…í•˜ì—¬ ê·¸ì— ë§ëŠ” frame delayë¥¼ ì„¤ì •í•  í•„ìš”ê°€ ìˆìŠµë‹ˆë‹¤.**

`requestAnimationFrame` ë™ì‘ ì‚¬ì´ì˜ timestampë¥¼ êµ¬í•˜ë©´ ëŒ€ëµì ì¸ ì£¼ì‚¬ìœ¨ì„ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
í•˜ì§€ë§Œ ì´ ì£¼ì‚¬ìœ¨ì€ ì •í™•í•œ ê°’ì´ ì•„ë‹™ë‹ˆë‹¤.
ì €ëŠ” 60Hzì˜ ëª¨ë‹ˆí„° ì‚¬ì–‘ì„ì—ë„ ì•„ë˜ì™€ ê°™ì€ ê°’ë“¤ì´ ë‚˜ì™”ìŠµë‹ˆë‹¤.. (timestampë¥¼ ì—¬ëŸ¬ë²ˆ êµ¬í•œ ê°’ë“¤ì…ë‹ˆë‹¤.)

<img src="/canvas-character-movement/8.png" width="400" />

<br />

ê·¸ë˜ë„ 60ì˜ ê°€ê¹Œìš´ ê°’ë“¤ì´ ì¶œë ¥ë˜ëŠ” ê²ƒì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
ë”°ë¼ì„œ 60Hz, 144Hz, 240Hzë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì¡ê³  timestampì™€ ê°€ì¥ ê°€ê¹Œìš´ ì£¼ì‚¬ìœ¨ì„ ì„ íƒí•˜ë„ë¡ í–ˆìŠµë‹ˆë‹¤.

ì•„ë˜ëŠ” ì‚¬ìš©ìì˜ ì£¼ì‚¬ìœ¨ì„ ì–»ëŠ” ìœ í‹¸ í•¨ìˆ˜ì…ë‹ˆë‹¤.

```ts
// getFrameRate.ts

const FRAME_RATES = [60, 144, 240];

export default async function getFrameRate() {
  let count = 0;
  let lastTime = 0;

  const framePrefixSum = new Map();

  FRAME_RATES.forEach((fps) => framePrefixSum.set(fps, 0));

  while (++count < 60) {
    const timeStamp = 1000 / (performance.now() - lastTime);

    const [frameRate] = FRAME_RATES.reduce(
      (accumulator, current) => {
        const diff = Math.abs(current - timeStamp);
        if (accumulator[1] > diff) {
          return [current, diff];
        }
        return accumulator;
      },
      [0, Infinity]
    );

    framePrefixSum.set(frameRate, framePrefixSum.get(frameRate) + 1);
    lastTime = performance.now();

    await new Promise((resolve) => {
      requestAnimationFrame(resolve);
    });
  }

  return FRAME_RATES.reduce((accumulator, current) => {
    if (framePrefixSum.get(accumulator) < framePrefixSum.get(current)) {
      return current;
    }
    return accumulator;
  });
}
```

ì¡°ê¸ˆì´ë¼ë„ ë†’ì€ ì •í™•ë„ë¡œ ì£¼ì‚¬ìœ¨ì„ ì•Œì•„ë‚´ê¸° ìœ„í•´ì„œ, timestampë¥¼ 60ë²ˆ êµ¬í•˜ê³  ì„ ì •ëœ ì£¼ì‚¬ìœ¨ì˜ íšŸìˆ˜ë¥¼ í†µí•´ ì‚¬ìš©ì ëª¨ë‹ˆí„° ì£¼ì‚¬ìœ¨ì„ ì–»ë„ë¡ í–ˆìŠµë‹ˆë‹¤.
ì´ëŠ” ë¹„ë™ê¸°ë¡œ ì‘ë™í•˜ê¸° ë•Œë¬¸ì— í”„ë¡œë¯¸ìŠ¤ë¥¼ ë¦¬í„´í•˜ë„ë¡ í•©ë‹ˆë‹¤.

<br />

## ìµœì¢… ê²°ê³¼

`getFrameRate` ìœ í‹¸ í•¨ìˆ˜ë¥¼ ì ìš©í•œ `Canvas` ì»´í¬ë„ŒíŠ¸ì™€ `Character` í´ë˜ìŠ¤ì…ë‹ˆë‹¤.

### * `Canvas` ì»´í¬ë„ŒíŠ¸

```tsx
// Canvas.tsx

import React, { useEffect } from 'react';
import { Wrapper } from './style';
import useCanvas from '@src/hooks/useCanvas';
import Character from '@src/graphics/Character';
import getFrameRate from '@src/utils/getFrameRate';
import mapBackground from '@public/images/map_background.jpeg';

const WIDTH = 1000;
const HEIGHT = 700;

const Canvas = () => {
  const charcterRef = useRef<Character | null>(null);
  const canvasRef = useCanvas(async (canvas) => {
    canvas.width = WIDTH;
    canvas.height = HEIGHT;
    canvas.style.background = `url(${mapBackground})`;

    const frameRate = await getFrameRate();
    charcterRef.current = new Character(canvas);
 
    if (charcterRef.current) {
      document.addEventListener('keydown', charcterRef.current.hadleArrowKeyDown());
    }
  });

  useEffect(() => {
    return () => {
      if (charcterRef.current) {
        document.removeEventListener('keydown', charcterRef.current.hadleArrowKeyDown());
      }
    };
  }, []);

  return (
    <Wrapper>
      <canvas ref={canvasRef} />
    </Wrapper>
  );
};

export default Canvas;
```

<br />
<br />

### * `Character` í´ë˜ìŠ¤

```ts
// Character.ts

import CharacterImages from './CharacterImages';
import throttle from '@src/utils/throttle';

interface Position {
  x: number;
  y: number;
}

enum Direction {
  DOWN = 0,
  UP = 1,
  LEFT = 2,
  RIGHT = 3,
}

const SIZE = 64;

class Character {
  private canvas: HTMLCanvasElement;
  private ctx: CanvasRenderingContext2D | null = null;
  private position: Position = { x: 0, y: 0 };
  private direction: number = Direction.DOWN;
  private frameDelay = 0;
  private frameCount = 0;

  constructor(canvas: HTMLCanvasElement, frameRate: number) {
    this.canvas = canvas;
    this.ctx = this.canvas.getContext('2d');
    this.frameDelay = frameRate / 3;
    this.runAnimationFrame();
  }

  private runAnimationFrame() {
    this.draw(++this.frameCount < this.frameDelay);
    requestAnimationFrame(this.runAnimationFrame.bind(this));
  }

  private draw(isDelayIn: boolean) {
    const { x, y } = this.position;
    const image = this.getImageByDirection(this.direction, isDelayIn);

    if (!this.ctx || !image) {
      return;
    }

    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.ctx.drawImage(image, x, y, SIZE, SIZE);
  }

  private getImageByDirection(direction: number, isWalking: boolean) {
    const {
      manDown,
      manDownWalk,
      manUp,
      manUpWalk,
      manLeft,
      manLeftWalk,
      manRight,
      manRightWalk,
    } = CharacterImages;

    switch (direction) {
      case Direction.UP:
        return isWalking ? manUpWalk : manUp;
      case Direction.DOWN:
        return isWalking ? manDownWalk : manDown;
      case Direction.LEFT:
        return isWalking ? manLeftWalk : manLeft;
      case Direction.RIGHT:
        return isWalking ? manRightWalk : manRight;
      default:
        return null;
    }
  }

  hadleArrowKeyDown() {
    const distance = SIZE;
    const ArrowKeys = [
      {
        code: '38',
        string: 'ArrowUp',
        direction: Direction.UP,
        movement: { x: 0, y: -distance },
        isMoveable: () => this.position.y > 0,
      },
      {
        code: '40',
        string: 'ArrowDown',
        direction: Direction.DOWN,
        movement: { x: 0, y: distance },
        isMoveable: () => this.position.y < this.canvas.height - SIZE,
      },
      {
        code: '39',
        string: 'ArrowRight',
        direction: Direction.RIGHT,
        movement: { x: distance, y: 0 },
        isMoveable: () => this.position.x < this.canvas.width - SIZE,
      },
      {
        code: '37',
        string: 'ArrowLeft',
        direction: Direction.LEFT,
        movement: { x: -distance, y: 0 },
        isMoveable: () => this.position.x > 0,
      },
    ];

    const handler = throttle((e: KeyboardEvent) => {
      for (let i = 0; i < ArrowKeys.length; i++) {
        const { code, string, direction, movement, isMoveable } = ArrowKeys[i];
        if ([code.toString(), string].includes(e.key) && isMoveable()) {
          this.position.x += movement.x;
          this.position.y += movement.y;
          this.direction = direction;
        }
        this.frameCount = 0;
      }
    }, 500);

    return (e: KeyboardEvent) => handler(e);
  }
}

export default Character;
```

<br />

- ğŸ’¡ `getFrameRate` í•¨ìˆ˜ê°€ ë™ì‘í•˜ëŠ” ë™ì•ˆ Reactì˜ `Suspense` ë˜ëŠ” `useEffect` Hook ë“±ì„ í™œìš©í•˜ì—¬ ë¡œë”© ì»´í¬ë„ŒíŠ¸ë¥¼ ë Œë”ë§ í•´ì£¼ë©´ ë” í›Œë¥­í•œ ê²°ê³¼ë¬¼ì„ ë§Œë“¤ ìˆ˜ ìˆì„ ê²ƒ ê°™ìŠµë‹ˆë‹¤.
- ğŸ’¡ í•´ë‹¹ ê¸€ì—ëŠ” ë°©í–¥ë³„ ê±·ëŠ” ì´ë¯¸ì§€ë¥¼ í•˜ë‚˜ë§Œ ì‚¬ìš©í•˜ê³  ìˆìŠµë‹ˆë‹¤. ë‹¤ë¦¬ê°€ êµì°¨í•˜ë„ë¡ ë‘ê°œì˜ ê±·ëŠ” ì´ë¯¸ì§€ë¥¼ í™œìš©í•œë‹¤ë©´ ë” ë©‹ì§„ ìºë¦­í„° ì´ë™ì„ êµ¬í˜„í•  ìˆ˜ ìˆì„ ê²ƒì…ë‹ˆë‹¤.

<br />

ì½”ë“œ ì´í•´ì— ì°¸ê³ ê°€ ë ê¹Œ í•˜ì—¬ ë””ë ‰í† ë¦¬ êµ¬ì¡° ì´ë¯¸ì§€ë„ ë„£ì—ˆìŠµë‹ˆë‹¤!

<img src="/canvas-character-movement/9.png" width="300" />

<br />
<br />

<p className="text-center">
  <strong>.</strong>
</p>

<p className="text-center">
  <strong>.</strong>
</p>

<p className="text-center">
  <strong>.</strong>
</p>

<br />

ìºë¦­í„° ì´ë™ì„ êµ¬í˜„í•˜ë©´ì„œ ì •ë§ ë§ì€ ë¬¸ì œë¥¼ ë§Œë‚¬ìŠµë‹ˆë‹¤.
ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ê³¼ì •ë“¤ì—ì„œ ë§ì€ ë¶€ë¶„ì„ í•™ìŠµí•  ìˆ˜ ìˆì—ˆë˜ ê²ƒ ê°™ì•„ì„œ ì¢‹ë„¤ìš”.
íŠ¹íˆ ì‚¬ìš©ì ë³„ë¡œ ë‹¤ë¥¸ ëª¨ë‹ˆí„° ì£¼ì‚¬ìœ¨ì„ íš¨ê³¼ì ìœ¼ë¡œ ë‹¤ë£¬ ê²ƒì´ ì œì¼ ë¿Œë“¯í•©ë‹ˆë‹¤.

 

ê³µìœ í•  ë‚´ìš©ì´ ë§ë‹¤ë³´ë‹ˆ ë””í…Œì¼í•˜ê²Œ ë‹¤ë£¨ì§€ ëª»í•œ ê²ƒ ê°™ë„¤ìš” ğŸ˜…
ê°œì„ í•  ì—¬ì§€ê°€ ìˆëŠ” ë¶€ë¶„ì´ ìˆë‹¤ë©´ ëŒ“ê¸€ ë¶€íƒë“œë¦½ë‹ˆë‹¤!